<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CORDLLE</title>
  <style>
    body {
      font-family: sans-serif;
      background: white;
      color: goldenrod;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
      min-height: 100vh;
      margin: 0;
    }
    h1 { font-size: 2.5rem; margin-bottom: 1rem; color: goldenrod; }

    .game-area {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      gap: 2rem;
      flex-wrap: nowrap;
      justify-content: center;
      width: 100%;
      max-width: 800px;
    }
    .questions {
      font-size: 1.2rem;
      min-width: 220px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .question-container { display: flex; align-items: center; gap: 0.5rem; }
    .question-text {
      background-color: #f5f5f5;
      border-left: 4px solid goldenrod;
      padding: 0.5rem;
      font-weight: bold;
      border-radius: 4px;
      flex-grow: 1;
      color: goldenrod;
    }
    .question-result {
      font-size: 1.5rem;
      color: goldenrod;
      width: 30px;
      text-align: center;
      visibility: hidden;
    }

    .guesses {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
      max-width: 17rem;
    }
    .row {
      display: flex;
      margin: 0.5rem 0;
      justify-content: flex-start;
      align-items: center;
      transition: transform 0.2s;
    }
    .row.shake { animation: shake 0.3s; }
    @keyframes shake {
      0%{transform:translateX(0)}
      25%{transform:translateX(-5px)}
      50%{transform:translateX(5px)}
      75%{transform:translateX(-5px)}
      100%{transform:translateX(0)}
    }

    .cell {
      width: 2.5rem;
      height: 2.5rem;
      font-size: 1.2rem;
      margin: 0.15rem;
      text-align: center;
      border: 2px solid #444;
      border-radius: 8px;
      background: #eee;
      color: goldenrod;
      text-transform: uppercase;
    }
    .cell.green { background: green; color: white; border-color: green; }
    .cell.yellow { background: goldenrod; color: white; border-color: goldenrod; }
    .cell.gray { background: #ccc; color: white; border-color: #ccc; }

    #game-over { margin-top: 1rem; font-size: 1.2rem; text-align: center; min-height: 2rem; }
    footer { margin-top: 2rem; color: goldenrod; font-weight: bold; }

    #start-screen {
      position: fixed;
      top:0; left:0; right:0; bottom:0;
      background:white;
      color:goldenrod;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:2rem;
      z-index:999;
    }
    #start-button {
      margin-top: 1rem;
      padding: 0.5rem 1.5rem;
      font-size: 1.2rem;
      cursor: pointer;
      color: goldenrod;
      background: white;
      border: 2px solid goldenrod;
      border-radius: 5px;
    }

    /* ===== Slide Menu ===== */
    #menu-toggle {
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 1100;
      background: #00bcd4;
      color: #121212;
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.1rem;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: background 0.2s ease, transform 0.2s ease;
    }
    #menu-toggle:hover { background:#00a0b7; transform: translateY(-1px); }
    body.menu-open #menu-toggle { background:#0097a7; color:#fff; }

    #menu-backdrop {
      position: fixed;
      inset:0;
      background: rgba(0,0,0,0.6);
      opacity:0;
      pointer-events:none;
      transition: opacity 0.3s ease;
      z-index:1000;
    }
    body.menu-open #menu-backdrop { opacity:1; pointer-events:auto; }

    #side-menu {
      position:fixed;
      top:0; left:0;
      height:100vh;
      width:min(320px,85vw);
      background:#fdfdfd;
      box-shadow:8px 0 24px rgba(0,0,0,0.25);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index:1050;
      padding:1.5rem 1.75rem 2rem;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      overflow-y:auto;
    }
    body.menu-open #side-menu { transform: translateX(0); }

    #side-menu h2 { margin:0; color:#00bcd4; font-size:1.5rem; }
    #side-menu p { margin:0; color:#333; line-height:1.4; }

    .login-panel {
      margin-top:1.5rem;
      background: rgba(0,0,0,0.03);
      padding:1rem 1.5rem;
      border-radius:12px;
      max-width:420px;
      width:100%;
      box-shadow: 0 8px 16px rgba(0,0,0,0.08);
      border: 1px solid #e5e5e5;
    }
    .login-panel label { display:block; font-weight:600; margin-bottom:0.5rem; }
    .login-row { display:flex; gap:0.5rem; }
    .login-panel input[type="text"] {
      flex:1;
      padding:0.6rem 0.8rem;
      border-radius:8px;
      border:1px solid #ccc;
      background:#fff;
      color:#111;
      font-size:1rem;
    }
    .login-panel input[type="text"]:focus {
      outline:none;
      border-color:#00bcd4;
      box-shadow:0 0 0 3px rgba(0,188,212,0.2);
    }
    .login-panel button {
      padding:0.6rem 1.2rem;
      border-radius:8px;
      border:none;
      background:#00bcd4;
      color:#fff;
      font-weight:600;
      cursor:pointer;
      transition: background 0.2s ease;
    }
    .login-panel button:hover { background:#0097a7; }
    .login-hint { margin-top:0.75rem; font-size:0.9rem; color:#666; }
    .external-link { margin-top:0.4rem; display:block; color:#00bcd4; font-weight:600; text-decoration:none; }
    .external-link:hover { color:#ff9800; text-decoration: underline; }
    #logout-button { margin-top:0.75rem; width:100%; background:#ef5350; }
    #logout-button:hover { background:#e53935; }

    .dark-toggle {
      margin-top: 1.5rem;
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-size:0.95rem;
      color:#333;
    }
    body.dark-mode .dark-toggle { color:#ddd; }
    .dark-toggle label {
      display:flex;
      align-items:center;
      justify-content:space-between;
      width:100%;
      cursor:pointer;
    }
    .dark-toggle input[type="checkbox"] {
      width: 2.5rem;
      height: 1.3rem;
      border-radius: 999px;
      appearance: none;
      -webkit-appearance: none;
      background: #ccc;
      position: relative;
      outline: none;
      border: none;
      transition: background 0.2s ease;
    }
    .dark-toggle input[type="checkbox"]::before {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 1rem;
      height: 1rem;
      border-radius: 50%;
      background: white;
      transition: transform 0.2s ease;
    }
    .dark-toggle input[type="checkbox"]:checked { background: #00bcd4; }
    .dark-toggle input[type="checkbox"]:checked::before { transform: translateX(1.1rem); }

    /* Dark mode overrides */

    /* ===== Streak (base styles) ===== */
    .streak-panel { 
      margin-top: 12px; padding: 10px 12px; border-radius: 10px; background:#fafafa; border:1px solid #e9e9e9; 
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02);
    }
    .streak-panel h3 { margin: 0 0 8px; font-size: 1.05rem; color:#b8860b; }
    .streak-row { display:flex; align-items: baseline; gap:8px; font-weight:700; }
    #streak-count { font-size: 1.6rem; color:#b8860b; }
    .streak-note { display:block; margin-top:6px; color:#777; font-size: .85rem; }

    body.dark-mode { background:#121212; color:#f5f5f5; }
    body.dark-mode h1,
    body.dark-mode .question-text,
    body.dark-mode .question-result,
    body.dark-mode footer { color:#ffd700; }
    body.dark-mode .question-text { background-color:#1f1f1f; border-left-color:#ffd700; }
    body.dark-mode .cell { background:#2a2a2a; border-color:#666; color:#ffd700; }
    body.dark-mode .cell.gray { background:#444; border-color:#444; color:#ccc; }
    body.dark-mode .cell.yellow { background:#b38f00; border-color:#b38f00; }
    body.dark-mode .cell.green { background:#2e7d32; border-color:#2e7d32; }
    body.dark-mode #start-screen { background:#121212; color:#ffd700; }
    body.dark-mode #menu-toggle { background:#263238; color:#ffd700; }
    body.dark-mode #menu-toggle:hover { background:#37474f; }
    body.dark-mode #side-menu { background:#1b1b1b; box-shadow:8px 0 24px rgba(0,0,0,0.65); }
    body.dark-mode #side-menu p,
    body.dark-mode .login-hint { color:#ddd; }
    body.dark-mode .login-panel {
      background: rgba(255,255,255,0.04);
      border-color:#333;
      box-shadow:0 8px 16px rgba(0,0,0,0.4);
    }
    body.dark-mode .login-panel input[type="text"] {
      background:#1e1e1e; color:#f5f5f5; border-color:#555;
    }
  </style>
</head>
<body>
  <button id="menu-toggle" type="button" aria-expanded="false" aria-controls="side-menu" aria-label="Toggle game menu">â˜° Menu</button>
  <div id="menu-backdrop" role="presentation"></div>
  <aside id="side-menu" aria-hidden="true" tabindex="-1">
    <div>
      <h2>Game Menu</h2>
      <p>Sign in to track your streak, then use Start Game below.</p>
      <div class="login-panel">
        <form id="login-form">
          <label for="username-input">Player username</label>
          <div class="login-row">
            <input id="username-input" name="username" type="text" placeholder="Enter username" autocomplete="nickname" required />
            <button type="submit" id="login-button">Log In</button>
          </div>
        </form>
        <button id="logout-button" type="button" style="display:none;">Log Out</button>
        <p class="login-hint">Your daily streak is saved per username on this device.</p>
        <a class="external-link" href="https://cordell33.github.io/GodlePuzzle/" target="_blank" rel="noopener noreferrer">Godle (daily)</a>
        <a class="external-link" href="https://cordell33.github.io/GodleHex/" target="_blank" rel="noopener noreferrer">GodleHex (weekly)</a>
      </div>
      <div class="streak-panel" id="streak" style="display:none;">
        <h3 id="streak-title">Monthly streak</h3>
        <div class="streak-row"><span id="streak-count">0</span><span>Days ðŸ”¥</span></div>
        <small class="streak-note" id="streak-note">Log in to start tracking.</small>
      </div>
    </div>
    <div class="dark-toggle">
      <label for="dark-mode-toggle">
        <span>Dark mode</span>
        <input id="dark-mode-toggle" type="checkbox" role="switch" aria-checked="false" />
      </label>
    </div>
  </aside>

  <div id="start-screen">
    <h1>Welcome to CORDLLE</h1>
    <p>A puzzle that uses logic and math using rules like GÃ¶dle</p>
    <ul style="text-align:left;max-width:400px;margin:0 auto;">
      <li>Answer the questions correctly</li>
      <li>This will help determine the final code word.</li>
      <li>Green = correct letter & position, Yellow = correct letter, wrong position.</li>
      <li>One letter will not be used and will be placed at the end.</li>
      <li>Share this with your friends.</li>
      <li>Good Luck!</li>
    </ul>
    <button id="start-button">Start Game</button>
  </div>

  <h1>CORDLLE </h1>
  <div class="game-area">
    <div class="questions" id="questions"></div>
    <div class="guesses" id="guess-container"></div>
  </div>
  <div id="game-over"></div>
  <footer>created by Cordell Booth</footer>

  <script>
    // ===== Game data (pyramid style) =====
    const questions = [
      "This letter is often followed by a 'u' 99% of the time",
      "A word meaning the opposite of affirmative",
      "To utter loudly",
      "The World's Most Famous Clown",
      "Sisco famous 90's song, about this?",
      "Catholics and Easten Orthadoxs had a great what, in 1054",
      "A regularly scheduled visit to a physician is called",
      "Often girls first and most popular toys",
      "" // final row has no visible question text
    ];

    const correctAnswers = [
      ["Q"],
      ["N", "O"],
      ["C", "R", "Y"],
      ["B", "O", "Z", "O"],
      ["T", "H", "O", "N", "G"],
      ["S", "C", "H", "I", "S", "M"],
      ["C", "H", "E", "C", "K", "U", "P"],
      ["B", "A", "B", "Y", "D", "O", "L", "L"],
      ["T", "R", "E", "A", "D", "M", "I", "L", "L"] // final CORDLLE word
    ];

    const pyramid = [1,2,3,4,5,6,7,8,9];
    const code    = correctAnswers[8];

    const questionsDiv   = document.getElementById("questions");
    const guessContainer = document.getElementById("guess-container");
    const gameOverDiv    = document.getElementById("game-over");
    const startScreen    = document.getElementById("start-screen");
    const startButton    = document.getElementById("start-button");

    // ===== Wordle-style feedback helper =====
    function getFeedback(inputArr, solution) {
      const feedback = new Array(inputArr.length).fill("gray");
      const solutionCopy = [...solution];

      // First pass: greens
      for (let i = 0; i < inputArr.length; i++) {
        if (inputArr[i] === solution[i]) {
          feedback[i] = "green";
          solutionCopy[i] = null;
        }
      }
      // Second pass: yellows
      for (let i = 0; i < inputArr.length; i++) {
        if (feedback[i] === "gray") {
          const idx = solutionCopy.indexOf(inputArr[i]);
          if (idx !== -1) {
            feedback[i] = "yellow";
            solutionCopy[idx] = null;
          }
        }
      }
      return feedback;
    }

    // ===== Evaluate a row =====
    function evaluate(inputArr, step) {
      const row    = document.getElementById(`row-${step}`);
      const result = document.getElementById(`result-${step}`);

      if (step < correctAnswers.length - 1) {
        // Question rows
        const expected = correctAnswers[step];
        const isCorrect =
          inputArr.length === expected.length &&
          inputArr.every((v, i) => v === expected[i]);

        if (!isCorrect) {
          row.classList.add("shake");
          setTimeout(() => row.classList.remove("shake"), 300);
          return;
        }

        if (result) {
          result.textContent = "âœ…";
          result.style.visibility = "visible";
        }

        const feedback = getFeedback(inputArr, code);
        const inputs   = row.querySelectorAll(".cell");
        inputs.forEach((input, i) => {
          input.classList.add(feedback[i]);
          input.disabled = true;
        });

        // Move focus to first cell of next row, if any
        const nextRow = document.getElementById(`row-${step + 1}`);
        if (nextRow) {
          const nextCells = nextRow.querySelectorAll(".cell");
          if (nextCells.length) {
            setTimeout(() => nextCells[0].focus(), 0);
          }
        }
      } else {
        // Final CORDLLE word row
        const feedback = getFeedback(inputArr, code);
        const inputs   = row.querySelectorAll(".cell");
        inputs.forEach((input, i) => {
          input.classList.add(feedback[i]);
          input.disabled = true;
        });

        const isCorrect =
          inputArr.length === code.length &&
          inputArr.every((v, i) => v === code[i]);

        // Only celebrate on correct; silent on wrong
        if (isCorrect) {
          gameOverDiv.textContent = "ðŸŽ‰ You cracked the code!";
        }
      }
    }

    // ===== Render pyramid + questions =====
    function renderQuestion() {
      questionsDiv.innerHTML   = "";
      guessContainer.innerHTML = "";

      for (let step = 0; step < pyramid.length; step++) {
        // Question text for rows 0..7
        if (step < questions.length - 1 && questions[step]) {
          const questionContainer = document.createElement("div");
          questionContainer.className = "question-container";

          const questionText = document.createElement("div");
          questionText.className = "question-text";
          questionText.textContent = questions[step];
          questionContainer.appendChild(questionText);

          const resultSpan = document.createElement("div");
          resultSpan.className = "question-result";
          resultSpan.id = `result-${step}`;
          questionContainer.appendChild(resultSpan);

          questionsDiv.appendChild(questionContainer);
        }

        // Label before final code row
        if (step === correctAnswers.length - 1) {
          const label = document.createElement("div");
          label.textContent = "Enter the CORDLLE word";
          label.style.fontWeight = "bold";
          label.style.marginTop = "1rem";
          label.style.alignSelf = "flex-start";
          guessContainer.appendChild(label);
        }

        const rowDiv = document.createElement("div");
        rowDiv.className = "row";
        rowDiv.style.justifyContent = "flex-start";
        rowDiv.id = `row-${step}`;

        const cellsInRow = pyramid[step];
        for (let i = 0; i < cellsInRow; i++) {
          const input = document.createElement("input");
          input.className = "cell";
          input.maxLength = 1;
          input.type = "text";
          input.autocomplete = "off";
          input.spellcheck = false;

          input.addEventListener("input", (e) => {
            input.value = input.value.toUpperCase().replace(/[^A-Z]/g, "");
            const siblings = Array.from(rowDiv.querySelectorAll(".cell"));
            const index = siblings.indexOf(input);
            if (e.target.value.length === 1 && index < siblings.length - 1) {
              siblings[index + 1].focus();
            }
          });

          input.addEventListener("keydown", (e) => {
            const siblings = Array.from(rowDiv.querySelectorAll(".cell"));
            const index = siblings.indexOf(input);

            if (e.key === "Enter") {
              const values = siblings.map(i => i.value.trim().toUpperCase());
              if (values.every(v => v !== "")) {
                evaluate(values, step);
              }
            }

            // Horizontal movement
            if (e.key === "ArrowLeft" && index > 0) {
              siblings[index - 1].focus();
              e.preventDefault();
            }
            if (e.key === "ArrowRight" && index < siblings.length - 1) {
              siblings[index + 1].focus();
              e.preventDefault();
            }

            // Vertical movement: nearest unfilled, enabled cell above/below
            if (e.key === "ArrowUp") {
              e.preventDefault();
              for (let r = step - 1; r >= 0; r--) {
                const prevRow = document.getElementById(`row-${r}`);
                if (!prevRow) continue;
                const prevCells = Array.from(prevRow.querySelectorAll(".cell"));
                const candidates = prevCells
                  .map((cell, idx) => ({ cell, idx }))
                  .filter(({ cell }) => !cell.disabled && cell.value === "");
                if (!candidates.length) continue;
                let best = candidates[0];
                let bestDist = Math.abs(best.idx - index);
                for (const cand of candidates) {
                  const dist = Math.abs(cand.idx - index);
                  if (dist < bestDist) {
                    best = cand;
                    bestDist = dist;
                  }
                }
                best.cell.focus();
                return;
              }
            }

            if (e.key === "ArrowDown") {
              e.preventDefault();
              for (let r = step + 1; r < pyramid.length; r++) {
                const nextRow = document.getElementById(`row-${r}`);
                if (!nextRow) continue;
                const nextCells = Array.from(nextRow.querySelectorAll(".cell"));
                const candidates = nextCells
                  .map((cell, idx) => ({ cell, idx }))
                  .filter(({ cell }) => !cell.disabled && cell.value === "");
                if (!candidates.length) continue;
                let best = candidates[0];
                let bestDist = Math.abs(best.idx - index);
                for (const cand of candidates) {
                  const dist = Math.abs(cand.idx - index);
                  if (dist < bestDist) {
                    best = cand;
                    bestDist = dist;
                  }
                }
                best.cell.focus();
                return;
              }
            }

            if ((e.key === "Backspace" || e.key === "Delete") && e.target.value === "" && index > 0) {
              siblings[index - 1].focus();
            }
          });

          rowDiv.appendChild(input);
        }

        guessContainer.appendChild(rowDiv);
      }
    }

    // ===== Menu wiring =====
    (function setupMenu(){
      const btn      = document.getElementById('menu-toggle');
      const aside    = document.getElementById('side-menu');
      const backdrop = document.getElementById('menu-backdrop');
      if (!btn || !aside || !backdrop) return;

      let lastFocus = null;
      const focusableSel = 'a[href], button:not([disabled]), input, textarea, select, [tabindex]:not([tabindex="-1"])';

      function isOpen(){ return document.body.classList.contains('menu-open'); }
      function open(){
        if (isOpen()) return;
        lastFocus = document.activeElement;
        document.body.classList.add('menu-open');
        btn.setAttribute('aria-expanded','true');
        aside.setAttribute('aria-hidden','false');
        btn.textContent = 'âœ• Close';
        setTimeout(()=>{ (aside.querySelector(focusableSel) || aside).focus(); }, 0);
      }
      function close(){
        if (!isOpen()) return;
        document.body.classList.remove('menu-open');
        btn.setAttribute('aria-expanded','false');
        aside.setAttribute('aria-hidden','true');
        btn.textContent = 'â˜° Menu';
        if (lastFocus && typeof lastFocus.focus === 'function') lastFocus.focus();
      }
      function toggle(){ isOpen() ? close() : open(); }

      btn.addEventListener('click', toggle);
      backdrop.addEventListener('click', close);
      window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') close(); });

      // Basic focus trap inside menu
      aside.addEventListener('keydown', (e)=>{
        if (!isOpen() || e.key !== 'Tab') return;
        const items = Array.from(aside.querySelectorAll(focusableSel)).filter(el => el.offsetParent !== null);
        if (!items.length) return;
        const first = items[0], last = items[items.length - 1];
        if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
        else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
      });
    })();

    // ===== Simple login with per-user monthly streak =====
    let currentUser = null;

    function monthKey(d = new Date()) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      return `${y}-${m}`;
    }

    function streakStorageKey(user, key = monthKey()) {
      return `cordlle:streak:${user}:${key}`;
    }

    function loadStreak(user, key = monthKey()) {
      try {
        const raw = localStorage.getItem(streakStorageKey(user, key));
        if (!raw) return { count: 0, lastDay: null };
        const data = JSON.parse(raw);
        return { count: Number(data.count)||0, lastDay: data.lastDay||null };
      } catch { return { count: 0, lastDay: null }; }
    }

    function saveStreak(user, data, key = monthKey()) {
      try { localStorage.setItem(streakStorageKey(user, key), JSON.stringify(data)); } catch {}
    }

    function showStreakPanel() {
      const panel = document.getElementById('streak');
      const title = document.getElementById('streak-title');
      const countEl = document.getElementById('streak-count');
      const note = document.getElementById('streak-note');
      if (!panel || !title || !countEl || !note) return;

      if (!currentUser) {
        panel.style.display = 'none';
        note.textContent = 'Log in to start tracking.';
        return;
      }
      const key = monthKey();
      const data = loadStreak(currentUser, key);
      panel.style.display = 'block';
      title.textContent = `Monthly streak â€” ${key}`;
      countEl.textContent = String(data.count||0);
      note.textContent = data.lastDay ? `Last activity: ${data.lastDay}` : 'No activity yet this month.';
    }

    function incrementStreakForToday() {
      if (!currentUser) return; // must be logged in
      const today = new Date();
      const keyNow = monthKey(today);

      // If the last saved month is different, we start fresh automatically (monthly reset)
      let data = loadStreak(currentUser, keyNow);
      const todayStr = today.toISOString().slice(0,10);
      if (data.lastDay === todayStr) { showStreakPanel(); return; } // already counted today
      data.count = (data.count||0) + 1;
      data.lastDay = todayStr;
      saveStreak(currentUser, data, keyNow);
      showStreakPanel();
    }

    (function setupLogin(){
      const loginForm     = document.getElementById("login-form");
      const usernameInput = document.getElementById("username-input");
      const logoutButton  = document.getElementById("logout-button");
      if (!loginForm || !usernameInput || !logoutButton) return;

      // Prefill from last session
      try {
        const savedUser = localStorage.getItem('cordlle:username');
        if (savedUser) {
          currentUser = savedUser;
          loginForm.style.display = 'none';
          logoutButton.style.display = 'block';
        }
      } catch {}
      showStreakPanel();

      loginForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const user = usernameInput.value.trim();
        if (!user) return;
        currentUser = user;
        try { localStorage.setItem('cordlle:username', user); } catch {}
        loginForm.style.display = "none";
        logoutButton.style.display = "block";
        showStreakPanel();
      });

      logoutButton.addEventListener("click", () => {
        loginForm.style.display = "block";
        logoutButton.style.display = "none";
        currentUser = null;
        showStreakPanel();
      });
    })();

    // ===== Dark mode toggle with persistence =====
    (function(){
      const toggle = document.getElementById('dark-mode-toggle');
      if (!toggle) return;
      const STORAGE_KEY = 'cordlle:dark-mode';
      const body = document.body;

      function apply(isDark){
        body.classList.toggle('dark-mode', isDark);
        toggle.checked = isDark;
        toggle.setAttribute('aria-checked', String(isDark));
      }

      let isDark = false;
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved !== null) {
          isDark = saved === 'true';
        } else if (window.matchMedia) {
          isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        }
      } catch (err) {
        isDark = body.classList.contains('dark-mode');
      }

      apply(isDark);

      toggle.addEventListener('change', () => {
        const next = !!toggle.checked;
        apply(next);
        try { localStorage.setItem(STORAGE_KEY, String(next)); } catch (err) {}
      });
    })();

    // ===== Start game =====
    startButton.addEventListener("click", () => {
      startScreen.style.display = "none";
      gameOverDiv.textContent = "";
      renderQuestion();
      // Count this dayâ€™s attempt when the player starts the puzzle
      incrementStreakForToday();
    });

    // ===== Tiny self-tests (non-breaking) =====
    (function devTests(){
      try {
        console.assert(typeof getFeedback === 'function', 'getFeedback missing');
        const allGreen = getFeedback(code, code).every(c => c === 'green');
        console.assert(allGreen, 'Final code feedback should be all green when input equals code');
      } catch(e) {
        // no-op
      }
    })();
  </script>
</body>
</html>
